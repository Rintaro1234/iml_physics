<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
  <title>
    情報メディア実験
  </title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="../../style.css" />
</head>

<body>
  <div class="main">
    <div class="title">
     Bulletによる物体のマウスピック
    </div>

    <ul class="header">
      <li><a href="#abst">マウスドラッグによる物体の移動の概要</a></li>
      <li><a href="#intersect">マウスクリックした点との交差判定</a></li>
      <li><a href="#constraint">Constraintの設定</a></li>
      <li><a href="#code">コード例</a></li>
    </ul>

    <div class="content">
    <a name="abst" id="abst"></a>
    <h2>マウスドラッグによる物体の移動の概要</h2>
    <p>
        Bulletのデモや実験のサンプルプログラムではマウスドラッグで剛体をつかんで動かすような動作ができるようになっている．
        これはデモ用のプログラム内部で，(1)マウスクリックした点との交差判定(光線(Ray)と剛体の衝突判定)，
        (2)交差点にConstraintを設定，を行うことで実現している．
    </p>
    <p>
      以下でそれぞれの実装手順を順番に説明していく．
    </p>
   

    <a name="intersect" id="intersect"></a>
    <h2>マウスクリックした点との交差判定</h2>
    <p>
      OpenGL(glew)のMouse関数にクリックしたときに視点座標とクリックした位置ベクトルを取得するコードを追加する．
      まず，実験のサンプルプログラムでは左ドラッグで視点移動になっているので(if(button == GLFW_MOUSE_BUTTON_LEFT)のところ)，
      そこを変更していく．
    </p>
    <pre class = "code">
if(button == GLFW_MOUSE_BUTTON_LEFT){
  if(action == GLFW_PRESS){
      // 視点，クリック位置の取得処理をここに記述
      // 元々あった視点移動の処理は動的剛体をクリックしなかった場合に行うようにする
  }
}
</pre>
    <p>
      実験サンプルプログラムでの視点座標の取得方法は<a href="../3_collision/index.html">衝突判定の説明ページの練習問題8</a>と同じ．
      クリック位置ベクトルの取得にはGetRayTo関数を用いる．
    </p>
    <pre class = "code">
glm::vec3 ray_from0, ray_to0;
g_view.CalLocalPos(ray_from0, glm::vec3(0, 0, 0));
g_view.GetRayTo(x, y, FOV, ray_to0);
    <p>
      得られた視点座標，クリック位置ベクトルはbtVector3型の変数に代入しておこう．
    </p>
    <pre class = "code">
btVector3 ray_from = btVector3(ray_from0[0], ray_from0[1], ray_from0[2]);
btVector3 ray_to = btVector3(ray_to0[0], ray_to0[1], ray_to0[2]);</pre>
    <p>
      視点座標が光線の原点，クリックした位置が光線のターゲット位置(光線方向=ターゲット位置-原点)となる．
    </p>
    <p>
      視点座標とクリック位置ベクトルを使ってマウスクリックした位置にあるオブジェクトを調べる．
      そのためにBulletワールドのrayTest関数を用いる．
      この関数ではこちらが指定した光線とワールド内のオブジェクトとの衝突判定を行ってくれる．
      rayTest関数は以下のようにして用いる．
    </p>
    pre class = "code">
btCollisionWorld::ClosestRayResultCallback ray_callback(ray_from, ray_to);
g_dynamicsworld-*&#x3e;rayTest(ray_from, ray_to, ray_callback);</pre>
    <p>
      ここでray_fromとray_toはそれぞれ光線の原点とターゲット位置(btVector3)である．
      衝突が検出されたかどうかは，ClosestRayResultCallbackクラスのhasHitメンバ関数で確かめることができる．
      また，m_collisionObjectメンバ変数(publicメンバ変数)に衝突オブジェクト(btCollisionObject)，
      m_hitPointWorldメンバ変数に衝突点(btVector3)がそれぞれ格納されている．
      さらに衝突オブジェクトが床などのstatic rigidbodyやkinematic rigidbodyの場合は動かす必要は無いので，
      btRigidBodyのisStaticObjectメンバ関数やisKinematicObjectメンバ関数を使って除外するようにする．
      これらの処理を行うコードを以下に示す．
    </p>
    <pre class = "code">
if(ray_callback.hasHit()){
  // 光線と衝突した剛体
  const btCollisionObject* obj = ray_callback.m_collisionObject;
  btRigidBody* body = const_cast&#x3c;btRigidBody*&#x3e;(btRigidBody::upcast(obj));

  // 衝突点座標(ジョイントになる位置座標)
  btVector3 picked_pos = ray_callback.m_hitPointWorld;

  if(body && !(body->isStaticObject() || body->isKinematicObject())){
    // ここに拘束条件を追加するコードを記述する
  }
}</pre>


    <a name="constraint" id="constraint"></a>
    <h2>Constraintの設定</h2>
    <p>
      光線との衝突点座標をジョイントとして"Point to Point Constraint"(btPoint2PointConstraint)を設定する．
      設定するためにはまず，以下のようにして衝突点の剛体ローカル座標における位置を求める必要がある．
    </p>
    <pre class = "code">
btVector3 local_pos = body->getCenterOfMassTransform().inverse()*picked_pos;
body->setActivationState(DISABLE_DEACTIVATION);</pre>
    <p>
      2行目は静止状態(getActivationStateで状態を取得)にしないようにピックしたオブジェクトを設定している．
      これは静止状態(Deactivate)では拘束条件がうまく働かないことがあるためである．
      衝突点ローカル座標を求めたら，その点をpivotInAとして1つのオブジェクトを空間中に拘束するようにbtPoint2PointConstraintを追加する
        (6DOF Constraintでもよい)．
    </p>
    <pre class = "code">
if(g_pickconstraint){
  g_dynamicsworld->removeConstraint(g_pickconstraint);
  delete g_pickconstraint;
}
g_pickconstraint = new btPoint2PointConstraint(*body, local_pos);
g_dynamicsworld->addConstraint(g_pickconstraint, true);</pre>
    <p>
      あとでMotion関数でも用いるのでConstraintは
      btPoint2PointConstraint*型のグローバル変数g_pickconstraintに格納してある．
    </p>
    <p>
      Constraintを設定できたらマウスをドラッグしたときにジョイントの位置を変更する．
      まず，クリックしたときと同様にして光線の情報(ray_fromとray_toとする)を計算する．
      マウスの動きは2次元であるのでこれを3次元空間での動きに変換しなければならない．
      ここでは視点を中心とした球状に動かすとする．
      この場合，視点と最初の衝突点の間の距離が常に保たれるようにすればよい．
      Mouse関数内で衝突が検出されたときに
    </p>
      <pre class = "code">
g_pickdist = (picked_pos-ray_from).length();</pre>
        のようにして衝突点までの距離を保存しておく．g_pickdistは衝突点までの距離を保存するグローバル変数である．
        そして，マウスドラッグ時の処理を行うMotion関数内でray_fromとray_toを前と同じ手順で求めた後，
        <pre class = "code">
btVector3 dir = ray_to-ray_from;
dir.normalize();
btVector3 new_pivot = ray_from+dir*g_pickdist;</pre>
        とすると新しいジョイント位置(ワールド座標)が求まる．
        ジョイントは2つのオブジェクトを接続するものであるが，
        今回は1つのオブジェクト(pivotInA)とワールド座標(pivotInB)を接続しているので，
        btPoint2PointConstraintのsetPivotBメンバ関数を使ってnew_pivotを直接指定してやればよい(ローカル座標への変換は必要ない)．
      </li>
      <li>
        最後にマウスボタンを放したときに設定していた拘束条件を破棄する．このとき，g_pickconstraint = 0と再初期化することを忘れないように．
      </li>
    </ol>
    これらの手順によりマウスによる物体の選択，移動が可能となる．
    また，Soft Constraintを使うとバネで引っ張るような効果も可能なので試してみよう
    (ただし，btPoint2PointConstraintにsetParamでCFMやERPを設定するとうまくいかないことがあるので，
    m_setting.m_tauを使うか，6DOF Constraintを使ってみるとよい)．
</p>
<p align="center">
  <img src="../fig/mouse_pick_cube.jpg" alt="Mouse Pick" /><br />
  マウスによるオブジェクト選択，移動<br />
</p>

    <p align="right">
    <a href="../index.html">戻る</a>
    </p>
    </div>

    <div class="footer">
    </div>
  </div>
</body>
</html>
